% !TeX root = ./spec.tex
\documentclass[12pt]{article}

\usepackage{graphicx}
\usepackage{paralist}
\usepackage{amsfonts}
\usepackage{amsmath}
\usepackage{hhline}
\usepackage{booktabs}
\usepackage{multirow}
\usepackage{multicol}
\usepackage{url}

\oddsidemargin -10mm
\evensidemargin -10mm
\textwidth 160mm
\textheight 200mm
\renewcommand\baselinestretch{1.0}

\pagestyle {plain}
\pagenumbering{arabic}

\newcounter{stepnum}

%% Comments

\usepackage{color}

\newif\ifcomments\commentstrue

\ifcomments
\newcommand{\authornote}[3]{\textcolor{#1}{[#3 ---#2]}}
\newcommand{\todo}[1]{\textcolor{red}{[TODO: #1]}}
\else
\newcommand{\authornote}[3]{}
\newcommand{\todo}[1]{}
\fi

\newcommand{\wss}[1]{\authornote{blue}{SS}{#1}}

\title{Shoppers Drug Mart Calculator Spec}
\author{Aditya Sharma}

\begin {document}

\maketitle
Module Interface Specification (MIS) document contains modules, types and
methods for implementing an online web application.

The purpose of this software product is to calculate the total price of customer's
cart items as they shop along in Shoppers Drug Mart (SDM).

\bibliographystyle{plain}
\bibliography{SmithCollectedRefs}

\newpage
\section{Overview}


\newpage
\section{Domain}

\subsection{Relevant Facts and Assumptions}

\subsection{Purpose}
\subsection{Stakeholders}
\subsubsection{Intended Audience}
The primary audience will be all SDM Customers.

\subsubsection{Impacted Groups/ Individuals}
The corporation known as Shoppers Drug Mart is a group that could be impacted by this application.
The impact on the corporation is currently unknown; however, this conclusion was drawn because of the
potential impact that this application could have on a SDM Customer. If the SDM Customer is impacted,
it would only be logical for the impact to stretch onto the company serving the customer.


\subsection{Product Scope}
The purpose of this application would be to track the total price of the all items that a
shopper would want to purchase from SDM. As a deliverable to the customer, the application will be 
providing the customer with a editable cart with a total price.


\newpage
\section{Functional Requirements}
\begin{itemize}
  \item The application needs to be geared towards predominantly mobile use
  \item The UI should be "card" based
  \item All items should be immediately visible
  \item The user should be able to add and delete items
  \item The items should have names, descriptions, price, applied discounts
  \item All the fields on the items should be editable
  \item The user should be able to apply particular discounts to particular items
  \item The user should be able to add as many items to their cart
  \item THe total price of all the items should be displayed

\end{itemize}

\newpage
\section*{Types Module}

\subsection{Item}
\begin{tabular}{| l | l | p{6cm} |}
  \hline
  \textbf{Property} & \textbf{Data Type}\\
  \hline
  itemName & string\\
  \hline
  itemDescription & string\\
  \hline
  itemInitialPrice & number\\
  \hline
  itemQuantity & number\\
  \hline
  itemDiscountType & string\\
  \hline
  itemDiscount & number\\
  \hline
  itemFinalPrice & number\\
  \hline
  deleteItem & boolean\\
  \hline
  \end{tabular}

\subsection{CardState}
\begin{tabular}{| l | l | p{6cm} |}
  \hline
  \textbf{Property} & \textbf{Data Type}\\
  \hline
  itemArray & Array$<$Item$>$\\
  \hline
  \end{tabular}







\newpage
\section*{ItemADT Module}

\subsection{Module}
ItemADT

\bigskip
\subsection{Uses}
\subsubsection{Imported Constants}
None

\subsubsection{Imported Data Types}
Item

\subsubsection{Imported Access Programs}
None

\bigskip
\subsection{Syntax}
\subsubsection{Exported Constants}
None

\subsubsection{Exported Types}
None
 
\subsubsection{Exported Functions}
None

\subsubsection{Exported Classes}
ItemADT

\subsubsection{Access Routine Interface}
\begin{tabular}{| l | l | l | p{5cm} |}
  \hline
  \textbf{Routine name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions}\\
  \hline
  constructor & Item (props) & ItemADT & ~\\
  \hline
  editItem & Item & ~ & ~\\
  \hline 
  deleteItem & Item & ~ & ~\\
  \hline
  \end{tabular}

\bigskip
\subsection{Semantics}
\subsubsection{State Variables}
item: Item

\subsubsection{State Invariants}
\begin{itemize}
  \item All properties of $item$ must have a value except for $item.itemDescription$
  \item All properties of $item$ must be editable/ changeable (must respond to user input)
\end{itemize}

\subsubsection{Assumptions}
None

\subsubsection{Access Routine Semantics}
constructor(props):
\begin{itemize}
  \item transition: bind $this$ to each routine
  \item output: $out :=$ self
  \item exception: none
\end{itemize}

\noindent editItem():
\begin{itemize}
  \item transition: none
  \item output: $out :=$ causes modal to pop-up
  \item exception: none
\end{itemize}

\noindent deleteItem():
\begin{itemize}
  \item transition: delete item from itemArray
  \item output: $out :=$ none
  \item exception: none
\end{itemize}








\newpage
\section*{Card Module}

\subsection{Module}
Card

\bigskip
\subsection{Uses}
\subsubsection{Imported Constants}
None

\subsubsection{Imported Data Types}
Item
ItemArray

\subsubsection{Imported Access Programs}
ItemADT

\bigskip
\subsection{Syntax}
\subsubsection{Exported Constants}
None

\subsubsection{Exported Types}
None
 
\subsubsection{Exported Functions}
None

\subsubsection{Exported Classes}
None

\subsubsection{Access Routine Interface}
\begin{tabular}{| l | l | l | p{5cm} |}
  \hline
  \textbf{Routine name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions}\\
  \hline
  constructor & any & Card & ~\\
  \hline
  \end{tabular}

\bigskip
\subsection{Semantics}
\subsubsection{State Variables}


\subsubsection{State Invariants}
\begin{itemize}
  \item 
\end{itemize}

\subsubsection{Assumptions}
None

\subsubsection{Access Routine Semantics}
None

\subsubsection{}







































\newpage
\section* {Land Use Type Module}

\subsection*{Module}

LanduseT

\subsection* {Uses}

N/A

\subsection* {Syntax}

\subsubsection* {Exported Constants}

None

\subsubsection* {Exported Types}

Landtypes = \{R, T, A, C\}\\

\noindent \textit{//R stands for Recreational, T for Transport, A for Agricultural, C for
  Commercial}

\subsubsection* {Exported Access Programs}

\begin{tabular}{| l | l | l | p{5cm} |}
\hline
\textbf{Routine name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions}\\
\hline
new LanduseT & Landtypes & LanduseT & ~\\
\hline
\end{tabular}

\subsection* {Semantics}

\subsubsection* {State Variables}

landuse: Landtypes

\subsubsection* {State Invariant}

None

\subsubsection* {Access Routine Semantics}

\noindent new LandUseT($t$):
\begin{itemize}
\item transition: $\mathit{landuse} := t$
\item output: $out := \mbox{self}$
\item exception: none
\end{itemize}

\subsubsection* {Considerations}

When implementing in Java, use enums (as shown in Tutorial 06 for ElementT).

\newpage

\section* {Point ADT Module}

\subsection*{Template Module inherits Equality(PointT)}

PointT

\subsection* {Uses}

N/A

\subsection* {Syntax}

\subsubsection* {Exported Types}

\wss{What should be written here?} PointT = ?

\subsubsection* {Exported Access Programs}

\begin{tabular}{| l | l | l | l |}
\hline
\textbf{Routine name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions}\\
\hline
PointT & $\mathbb{Z}$, $\mathbb{Z}$ & PointT & \\
\hline
row & ~ & $\mathbb{Z}$ & ~\\
\hline
col & ~ & $\mathbb{Z}$ & ~\\
\hline
translate & $\mathbb{Z}$, $\mathbb{Z}$ & PointT & ~\\
\hline
\end{tabular}

\subsection* {Semantics}

\subsubsection* {State Variables}

$r$: \wss{What is the type of the state variables?} $\mathbb{Z}$\\
$c$: \wss{What is the type of the state variables?} $\mathbb{Z}$\\

\subsubsection* {State Invariant}

None

\subsubsection* {Assumptions}

The constructor PointT is called for each object instance before any other
access routine is called for that object.  The constructor cannot be called on
an existing object.

\subsubsection* {Access Routine Semantics}

PointT($row, col$):
\begin{itemize}
\item transition: \wss{What should the state transition be for the constructor?} r, c := row, col
\item output: $out := \mathit{self}$
\item exception: None
\end{itemize}

\noindent row():
\begin{itemize}
\item output: $out := r$
\item exception: None
\end{itemize}

\noindent col():
\begin{itemize}
\item \wss{What should go here?} output: $out := c$
\item exception: None
\end{itemize}

\noindent translate($\Delta r$, $\Delta c$):
\begin{itemize}
\item \wss{What should go here?} output: $out :=$ PointT(r + $\Delta r$, c + $\Delta c$)
\item exception: \wss{What should go here?} None
\end{itemize}

\newpage

\section* {Generic Seq2D Module}

\subsection* {Generic Template Module}

Seq2D(T)

\subsection* {Uses}

PointT

\subsection* {Syntax}

\subsubsection* {Exported Types}

Seq2D(T) = ?

\subsubsection* {Exported Constants}

None

\subsubsection* {Exported Access Programs}

\begin{tabular}{| l | l | l | p{6cm} |}
\hline
\textbf{Routine name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions}\\
\hline
Seq2D & seq of (seq of T), $\mathbb{R}$ & Seq2D & IllegalArgumentException\\
\hline
set & PointT, T & ~ & IndexOutOfBoundsException\\
\hline
get & PointT & T & IndexOutOfBoundsException\\
\hline
getNumRow & ~ & $\mathbb{N}$ & \\
\hline
getNumCol & ~ & $\mathbb{N}$ & \\
\hline
getScale & ~ & $\mathbb{R}$ & \\
\hline
count & T & $\mathbb{N}$ & \\
\hline
countRow & T, $\mathbb{N}$ & $\mathbb{N}$ & \\
\hline
area & T & $\mathbb{R}$ & \\
\hline
\end{tabular}

\subsection* {Semantics}

\subsubsection* {State Variables}

$s$: seq of (seq of T)\\
scale: $\mathbb{R}$\\
nRow: $\mathbb{N}$\\
nCol: $\mathbb{N}$

\subsubsection* {State Invariant}

None

\subsubsection* {Assumptions}

\begin{itemize}
\item The Seq2D(T) constructor is called for each object instance before any
other access routine is called for that object.  The constructor can only be
called once.
\item Assume that the input to the constructor is a sequence of rows, where each
  row is a sequence of elements of type T.  The number of columns (number of
  elements) in each row is assumed to be equal. That is each row
  of the grid has the same number of entries.  $s[i][j]$ means the ith row and
  the jth column.  The 0th row is at the top of the grid and the 0th column
  is at the leftmost side of the grid.
\end{itemize}

\subsubsection* {Access Routine Semantics}

Seq2D($S$, scl):
\begin{itemize}
\item transition: \wss{Fill in the transition.} s, scale, nRow, nCol = $S, scl, |\text{S}|, |\text{S[0]}|$
\item output: $\mathit{out} := \mathit{self}$
\item exception: \wss{Fill in the exception.  One should be generated if the
    scale is less than zero, or the input sequence is empty, or the number of
    columns is zero in the first row, or the number of columns in any row is
    different from the number of columns in the first row.} $(scale < 0) \lor (s = \emptyset) \lor (s[0] = \emptyset) \lor (\exists i: \mathbb{N} | i \in [1 .. |s|-1] : (|s[i]| \neq |s[0]|)$
\end{itemize}

\noindent set($p, v$):
\begin{itemize}
\item transition: \wss{?} s$[p.r][p.c]$ := v
\item exception: \wss{Generate an exception if the point lies outside of the
    map.} ($\neg$validPoint(p) $\Rightarrow$ IndexOutOfBoundsException)
\end{itemize}

\noindent get($p$):
\begin{itemize}
\item output: \wss{?} $out$ := s$[p.r][p.c]$
\item exception: \wss{Generate an exception if the point lies outside of the
    map.} ($\neg$validPoint(p) $\Rightarrow$ IndexOutOfBoundsException)
\end{itemize}

\noindent getNumRow():
\begin{itemize}
\item output: $out := \mbox{nRow}$
\item exception: None
\end{itemize}

\noindent getNumCol():
\begin{itemize}
\item output: $out := \mbox{nCol}$
\item exception: None
\end{itemize}

\noindent getScale():
\begin{itemize}
\item output: $out := \mbox{scale}$
\item exception: None
\end{itemize}

\noindent count($t$: T):
\begin{itemize}
\item output: \wss{Count the number of times the value $t$ occurs in the 2D
    sequence.} $out := (+i,j : \mathbb{N} | \text{validRow}(i) \wedge \text{validCol}(j) \wedge s[i][j] = t : 1)$
\item exception: None
\end{itemize}

\noindent countRow($t$: T, $i: \mathbb{N}$):
\begin{itemize}
\item output: \wss{Count the number of times the value $t$ occurs in row
    $i$.} $out:= + (elem:T | \text{validRow}(i) \wedge elem \in s[i] \wedge elem = t: 1)$
\item exception: \wss{Generate an exception if the index is not a valid
    row.} $\neg \text{validRow(i)} \Rightarrow IndexOutOfBoundsException$
\end{itemize}

\noindent area($t$: T):
\begin{itemize}
\item output: \wss{Return the total area in the grid taken up by cell value $t$.
    The length of each side of each cell in the grid is
    scale.} $out := \text{count(T)} \cdot \text{scale}^2$
\item exception: None
\end{itemize}

\subsection*{Local Functions}

\noindent validRow: $\mathbb{N} \rightarrow \mathbb{B}$\\
\noindent \wss{returns true if the given natural number is a valid row
  number.}\\ $\text{validRow(i)} \equiv (i \geq 0 \wedge i < \text{nRow} \Rightarrow True | i < 0 \lor i \geq \text{nRow} \Rightarrow False)$\\

\noindent validCol: $\mathbb{N} \rightarrow \mathbb{B}$\\
\noindent \wss{returns true if the given natural number is a valid column
  number.}\\ $(\text{validCol(j)} \equiv (j \geq 0 \wedge j < \text{nCol} \Rightarrow True | j < 0 \lor j \geq \text{nCol} \Rightarrow False)$\\

\noindent validPoint: $\mbox{PointT} \rightarrow \mathbb{B}$\\
\noindent \wss{Returns true if the given point lies within the boundaries of the
  map.}\\ $\text{validPoint(T)} \equiv ()\text{validRow(T.row())} \wedge \text{validCol(T.col())} \Rightarrow True | \neg\text{validRow(T.row())} \lor \neg\text{validCol(T.col())} \Rightarrow False)$\\

\newpage

\section* {LanduseMap Module}

\subsection* {Template Module}

\wss{Instantiate the generic ADT Seq2D(T) with the type LanduseT}\\ LanduseMap is Seq2D(LanduseT)

\newpage

\section* {DEM Module}

\subsection* {Template Module}

DemT is Seq2D($\mathbb{Z}$)

\subsection* {Syntax}

\subsubsection* {Exported Access Programs}

\begin{tabular}{| l | l | l | p{6cm} |}
\hline
\textbf{Routine name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions}\\
\hline
total & & $\mathbb{Z}$ & \\
\hline
max &  & $\mathbb{Z}$ & \\
\hline
ascendingRows & & $\mathbb{B}$ & \\
\hline
\end{tabular}

\subsection* {Semantics}

\subsubsection* {Access Routine Semantics}

\noindent total():
\begin{itemize}
\item output: \wss{Total of all the values in all of the cells.}\\
$out := (+ i,j: \mathbb{N}| \text{validRow}(i) \wedge \text{validCol}(j): s[i][j])$
\item exception: None
\end{itemize}

\noindent max():
\begin{itemize}
\item output: \wss{Find the maximum value in the 2d grid of integers}\\
$out := (m: \mathbb{Z} | \forall(i,j: \mathbb{N}| \text{validRow}(i) \wedge \text{validCol}(j) \wedge m \geq s[i][j]) \land \exists(i,j : \mathbb{N}| s[i][j] = m): s[i][j])$\\
\item exception: None
\end{itemize}

\noindent ascendingRows():
\begin{itemize}
\item output: \wss{Returns True if the sum of all values in each row increases
    as the row number increases, otherwise, returns False.}\\
$out := (\forall i: \mathbb{N} | \text{validRow}(i) \wedge \text{validRow}(i+1): \text{sumRow}(i) < \text{sumRow}(i+1))$
\item exception: None
\end{itemize}

\subsection*{Local Functions}

\noindent validRow: $\mathbb{N} \rightarrow \mathbb{B}$\\
\noindent \wss{returns true if the given natural number is a valid row
  number.}\\ $\text{validRow(i)} \equiv (i \geq 0 \wedge i < \text{nRow} \Rightarrow True | i < 0 \lor i \geq \text{nRow} \Rightarrow False)$\\

\noindent validCol: $\mathbb{N} \rightarrow \mathbb{B}$\\
\noindent \wss{returns true if the given natural number is a valid column
  number.}\\ $(\text{validCol(j)} \equiv (j \geq 0 \wedge j < \text{nCol} \Rightarrow True | j < 0 \lor j \geq \text{nCol} \Rightarrow False)$\\

\noindent sumRow: $\mathbb{N} \times \mathbb{N} \rightarrow \mathbb{N}$\\
\noindent \wss{returns the sum of a particular row.}\\
$\text{sumRow}(i) \equiv (+ j: \mathbb{N} | \text{validRow}(i) \wedge \text{validCol}(j) \wedge s[i][j] \in s[i]: s[i][j])$

\newpage

\section*{Critique of Design}
\wss{Write a critique of the interface for the modules in this project.  Is there
anything missing?  Is there anything you would consider changing?  Why?  One
thing you could discuss is that the Java implementation, following the notes
given in the assignment description, will expose the use of ArrayList for Seq2D.
How might you change this?  There are repeated local functions in two modules.
What could you do about this?} \\

No, I don't believe that there is anything missing regarding the interface for the modules with regards to the methods.
The reason is because each module interface had a particular goal and each interface succinctly described the methods that would
be used to achieve the goal - no more were needed. With regards to the Software Engineering Principles, I believe that majority of the 
Software Engineering Principles were followed. 
\begin{itemize}
  \item Consistency: The module interfaces were consistent because they followed the same naming conventions.
  Also, if I were given just a little bit of information regarding the modules, I would be able to piece the rest 
  of them together.
  \item Essential: The module interfaces satisfied the criteria of being essential because they included useful features. 
  They didn't include any over-the-top, creative/ somewhat-useless features. Each module had a particular goal and they 
  had methods that worked togehter to achieve that goal/ purpose.
  \item Minimal: The module interface satisfied the criteria of being minimal because they didn't offer methods that provided
  uniquely independent/ seperate access routines. Each of the routines were somewhat related to each other and would be utilized 
  together to achieve a particular goal.
  \item Opaque: The module interfaces were opaque and this supported information hiding/ encapsulation. This is because the modules
  were designed in a way such that if the implementation of the particular methods changed, then the overall action would not change.
  However, this is assuming that the specifications were followed exactly.
  \item Low Coupling and High Cohesion: The module interfaces did satisfiy Low Coupling because they weren't strongly dependent on each other. They were 
  created to work with each other but they aren't overly dependent on each other. However, at the same time, they aren't enough modules for me low coupling to be completely valid.
  At the same time, the module interfaces satisfied High Cohesion because of how the methods within modules could be used within other methods for other tasks. It had a high cohesivenesss.
  \item General: The module interfaces were general because they didn't require super specific data types or particular implementation details.
  Seq2D used generic types and PointT established generic types too. They weren't super specific and that was why it satisfies the quality of being general.
  It allows them to be used for multiple situations.
\end{itemize}

As mentioned in the assignment description, ArrayLists will be used in the Java Implementation. From a design standpoint, I would change this because this is the opposite
of information hiding. In information hiding, we should hide the implementation details behind an interface. However, by exposing the fact that ArrayLists should and will be
used in the implementation, we are exposing this implementation detail to the developer. In order to enforce information hiding, the description and MIS should not have
disclosed this fact and should not be enforcing it. If I were to make a change, the first change I would do is make the necessary changes to enforce information hiding. Then,
I would specify that a particular data type is used to store the information (making things as abstract/ generic as possible).\\

%The module interface for Seq2D will be using an ArrayList for its Java Implementation. However, I am a little unsure of the implementation details
%as to how an ArrayList would be leveraged. If both sequences are composed of ArrayLists, then there would be an issue.
%By using an ArrayList, things become a little more prone to error because now the size of the Array is dynamic and the size maintenance would be dependent
%on the user. This increases the margin of error because it becomes more likely that the user will accidently add more columns in one row than in the others.
%This increases the probability of an exception being thrown. I would avoid this by implementing an Array of a fixed size specified by the user. This still provides the user with the
%feel of input. However, it takes away the ability to be resized throughout the use of the program and ensures that the grid remains of a fixed size. Furthermore,
%by leveraging an Array instead of an ArrayList, we can avoid resizing the data structure and this increases efficiency (performance).
%correctness, robustness and performance increase.\\

I also noticed that there were repeated local functions in the two modules. This is bad practice because the exact same
code is being re-written. Instead, it should be reused. Since those local functions were used in the exceptions, I would
create a Module Interface where those local functions are methods. This would allow for reuse by the other modules that leveraged
exceptions that rely on the local functions. This in turn improves the quality of the software system. \\

In addition to your critique, please address the following questions:
\begin{enumerate}
\item The original version of the assignment had an Equality interface defined
  as for A2, but this idea was dropped.  In the original version Seq2D inherited
  the Equality interface.  Although this works in Java with the LanduseMapT, it is
  problematic for DemT.  Why is it problematic?  (Hint: DEMT is instantiated
  with the Java type Integer.)\\
  Its problematic because there is a difference in types. So, while the equality interface is used to handle generic types and comparisons between
  such types, the DemT is using numbers. We can't perform comparisons the exact same way because integers use a different form of comparison than generic types.
  Assuming that Generic Types is referring to ADTs, these ADTs will have references which is why we can't perform comparisons via "==" the way integers do. As a result, there needs to be a different
  type of way to determine if the Generic Types are equal. But since DemT uses an integer, the way we determine equality with generic types will be different than the
  way we determine equality for integers. That is why it would be problematic.


\item Although Java has several interfaces as part of the standard language,
  such as the Comparable interface, there is no Equality interface.  Instead
  equals is provided through inheritance from Object.  Why do you think the
  Java language designers decided to use inheritance for equality, instead of
  providing an interface?\\

  I think that Java language designers decided to use inheritance for equality instead of an interface
  because with inheritance for equality, we can perform overloading or overriding. This allows us to handle different
  types and numbers of parameters for our equality functions. If an interface would have been used, then 
  we would need to implement the interface exactly. And an interface specifies the particular types for the variables 
  we need to implement, but with inheritance, we can change the data types of variables to match our needs. We wouldn't be able to design for change if we used an interface.
  In addition, it allows for reuse. For example: If I design an interface to allow for equality for Grid objects. I won't be able
  to use that same interface to determine if Map objects are equal. I can only implement it for Grid objects. However, with inheritance,
  I can quickly inherit key properties and simply change the data types. 

\item The qualities of good module interface push the design of the interface in
  different directions. Why is it rarely possible to achieve a module interface
  that simultaneously is essential, minimal and general?\\

  A module interface is said to be essential when it contains methods that are essential to accomplishing its purpose; when it 
  does not include any unnecessary access routines. A module interface is said to be general when it is able to satisfy
  unpredictable usecases. A module interface is said to be minimal if it does not have 2 access routines that provide independent
  services.
  
  The issue arises when we want to make a module general. By doing so, in order to make it useful in unpredictable cases, we need to
  include unique, creative/ abstract methods. However, by doing so, these routines will most likely be unnecessary for the key functionality
  of the module. Thus, by making it general, we would not make it essential. In addition, by making it general, we would have unique routines
  that would most likely provide independent services and this would make the module not minimal. This showcases it becomes difficult to make a
  module general, minimal and essential.

\end{enumerate}

\end {document}